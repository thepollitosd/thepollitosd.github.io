<!DOCTYPE html>
<html>
<head>
    <title>Slither Clone</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #111; }
        canvas { display: block; margin: auto; background-color: #222; /* Temporary BG */ }
        /* Add styles for score, menus etc. later */
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <script>
// --- Basic Setup ---
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

let canvasWidth = window.innerWidth;
let canvasHeight = window.innerHeight;
canvas.width = canvasWidth;
canvas.height = canvasHeight;

window.addEventListener('resize', () => {
    canvasWidth = window.innerWidth;
    canvasHeight = window.innerHeight;
    canvas.width = canvasWidth;
    canvas.height = canvasHeight;
});

// --- Game State ---
let playerSnake;
let aiSnakes = [];
let food = [];
let score = 0;
let gameState = 'playing'; // or 'menu', 'gameOver'
const worldSize = 5000; // Virtual size of the game world
const foodCount = 200;
const aiCount = 10;

// Camera position (top-left corner of the visible area in world coordinates)
let cameraX = 0;
let cameraY = 0;

// Target direction (angle in radians)
let targetAngle = 0;
let currentAngle = 0;
const turnSpeed = 0.1; // Radians per frame adjustment
const baseSpeed = 1.5; // Pixels per frame - MAKE THIS SLOW!

// --- Game Loop ---
let lastTimestamp = 0;
function gameLoop(timestamp) {
    const deltaTime = (timestamp - lastTimestamp) / 1000; // Time since last frame in seconds
    lastTimestamp = timestamp;

    if (gameState === 'playing') {
        update(deltaTime);
        render();
    } else if (gameState === 'gameOver') {
        // Show game over screen
    }

    requestAnimationFrame(gameLoop);
}

// --- Update Function ---
function update(deltaTime) {
    // Smoothly turn player snake towards target angle
    // Handle angle wrapping (e.g., from 2PI to 0)
    let angleDiff = targetAngle - currentAngle;
    while (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;
    while (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;
    currentAngle += angleDiff * turnSpeed; // Adjust turn speed for smoothness

    playerSnake.update(currentAngle, baseSpeed); // Pass angle and speed

    // Update AI Snakes
    aiSnakes.forEach(ai => ai.updateAI(playerSnake, food, aiSnakes));

    // Check Collisions (food, other snakes)
    checkCollisions();

    // Update Camera to follow player
    // Center the player on screen
    cameraX = playerSnake.x - canvasWidth / 2;
    cameraY = playerSnake.y - canvasHeight / 2;

    // Clamp camera to world boundaries (optional, but good practice)
    // cameraX = Math.max(0, Math.min(worldSize - canvasWidth, cameraX));
    // cameraY = Math.max(0, Math.min(worldSize - canvasHeight, cameraY));
}

// --- Render Function ---
function render() {
    // Clear canvas
    ctx.fillStyle = '#1a1a1a'; // Dark background like original
    ctx.fillRect(0, 0, canvasWidth, canvasHeight);

    // --- Apply Camera Transform ---
    // IMPORTANT: Everything drawn after this is relative to the world
    ctx.save();
    ctx.translate(-cameraX, -cameraY);

    // Draw Background Grid (Example)
    drawGrid();

    // Draw Food
    food.forEach(f => f.draw(ctx));

    // Draw AI Snakes
    aiSnakes.forEach(ai => ai.draw(ctx));

    // Draw Player Snake
    playerSnake.draw(ctx);

    // --- Restore Context ---
    // IMPORTANT: Anything drawn after this is relative to the screen (like UI)
    ctx.restore();

    // Draw Score, UI elements, etc. on top
    ctx.fillStyle = 'white';
    ctx.font = '20px Arial';
    ctx.fillText(`Score: ${score}`, 10, 30);

     // Draw minimap (optional advanced feature)
}

// --- Helper: Draw Background Grid ---
function drawGrid() {
    const gridSize = 50;
    ctx.strokeStyle = '#333'; // Dark grid lines
    ctx.lineWidth = 1;

    // Calculate visible grid lines based on camera position
    const startX = Math.floor(cameraX / gridSize) * gridSize;
    const startY = Math.floor(cameraY / gridSize) * gridSize;
    const endX = cameraX + canvasWidth;
    const endY = cameraY + canvasHeight;

    for (let x = startX; x < endX; x += gridSize) {
        ctx.beginPath();
        ctx.moveTo(x, startY);
        ctx.lineTo(x, endY);
        ctx.stroke();
    }
    for (let y = startY; y < endY; y += gridSize) {
        ctx.beginPath();
        ctx.moveTo(startX, y);
        ctx.lineTo(endX, y);
        ctx.stroke();
    }
}


// --- Initialization ---
function init() {
    // Create player snake instance
    playerSnake = new Snake(worldSize / 2, worldSize / 2, 10, '#00FF00'); // Start pos, initial size, color

    // Create AI snakes
    aiSnakes = [];
    for (let i = 0; i < aiCount; i++) {
        const aiX = Math.random() * worldSize;
        const aiY = Math.random() * worldSize;
        const aiColor = `hsl(${Math.random() * 360}, 70%, 50%)`;
        aiSnakes.push(new Snake(aiX, aiY, 8, aiColor, true)); // isAI = true
    }

    // Create food
    food = [];
    for (let i = 0; i < foodCount; i++) {
        food.push(new Food(Math.random() * worldSize, Math.random() * worldSize));
    }

    // Setup Controls
    setupControls();

    // Start the game loop
    lastTimestamp = performance.now();
    requestAnimationFrame(gameLoop);
}

// --- Classes (Simplified) ---

class Food {
    constructor(x, y) {
        this.x = x;
        this.y = y;
        this.radius = 5;
        this.color = `hsl(${Math.random() * 360}, 100%, 70%)`; // Bright food colors
    }

    draw(ctx) {
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
        ctx.fillStyle = this.color;
        ctx.fill();
        // Add a slight glow maybe?
        ctx.shadowBlur = 5;
        ctx.shadowColor = this.color;
        ctx.fill();
        ctx.shadowBlur = 0; // Reset shadow
    }
}

class Snake {
    constructor(x, y, initialLength, color, isAI = false) {
        this.x = x; // Head X
        this.y = y; // Head Y
        this.color = color;
        this.segments = []; // Array of {x, y} points
        this.segmentGap = 5; // Distance between segment centers
        this.radius = 8; // Thickness of the snake
        this.length = initialLength; // Target number of segments
        this.isAI = isAI;
        this.aiState = 'wandering'; // For AI: wandering, seekingFood, avoiding, attacking
        this.target = null; // For AI: target food or position
        this.aiTurnSpeed = 0.05 + Math.random() * 0.05; // AI turning variability
        this.currentAngle = Math.random() * Math.PI * 2; // Initial angle

        // Initialize segments behind the head
        for (let i = 0; i < initialLength; i++) {
            this.segments.push({ x: x - i * this.segmentGap, y: y });
        }
    }

    update(angle, speed) {
        this.currentAngle = angle; // Update angle based on input/AI

        // Move head
        const vx = Math.cos(this.currentAngle) * speed;
        const vy = Math.sin(this.currentAngle) * speed;
        this.x += vx;
        this.y += vy;

        // Keep head within world bounds (simple wrap-around or clamp)
        // this.x = (this.x + worldSize) % worldSize;
        // this.y = (this.y + worldSize) % worldSize;

        // Move segments (follow the leader)
        this.segments.unshift({ x: this.x, y: this.y }); // Add new head position

        // Keep segments spaced correctly - Iterate and adjust towards the previous segment
        for (let i = 1; i < this.segments.length; i++) {
             const prevSeg = this.segments[i - 1];
             const currentSeg = this.segments[i];
             const dx = prevSeg.x - currentSeg.x;
             const dy = prevSeg.y - currentSeg.y;
             const distance = Math.sqrt(dx * dx + dy * dy);

             if (distance > this.segmentGap) {
                const moveX = (dx / distance) * (distance - this.segmentGap);
                const moveY = (dy / distance) * (distance - this.segmentGap);
                currentSeg.x += moveX;
                currentSeg.y += moveY;
             }
        }


        // Remove excess segments if snake hasn't grown
        while (this.segments.length > this.length) {
            this.segments.pop();
        }
    }

    // --- AI Logic ---
    updateAI(player, allFood, otherSnakes) {
        if (!this.isAI) return;

        // Simple State Machine Example
        // 1. Find nearest food
        let closestFood = null;
        let minDistSq = Infinity;
        allFood.forEach(f => {
            const dx = f.x - this.x;
            const dy = f.y - this.y;
            const distSq = dx*dx + dy*dy;
            if (distSq < minDistSq) {
                minDistSq = distSq;
                closestFood = f;
            }
        });

        // 2. Basic "Attack Player" logic (if close enough)
        const playerDistSq = (player.x - this.x)**2 + (player.y - this.y)**2;
        const attackRangeSq = (300 * 300); // Attack if player is within 300px

        let targetX, targetY;

        if (playerDistSq < attackRangeSq && player.length > this.length/2) { // Don't suicide attack tiny players
             this.aiState = 'attacking';
             // Aim slightly ahead of the player to intercept
             const predictTime = 1.0; // How far ahead to predict in seconds (adjust)
             const playerSpeed = baseSpeed; // Assume player speed for now
             const playerVx = Math.cos(player.currentAngle) * playerSpeed;
             const playerVy = Math.sin(player.currentAngle) * playerSpeed;
             targetX = player.x + playerVx * predictTime * 60; // * 60 assumes ~60fps
             targetY = player.y + playerVy * predictTime * 60;

        } else if (closestFood) {
            this.aiState = 'seekingFood';
            targetX = closestFood.x;
            targetY = closestFood.y;
        } else {
            // Wander aimlessly (change target angle slightly over time)
            this.aiState = 'wandering';
             if (!this.wanderTarget || Math.random() < 0.01) { // Pick new wander point occasionally
                this.wanderTarget = {
                    x: this.x + (Math.random() - 0.5) * 500,
                    y: this.y + (Math.random() - 0.5) * 500
                };
            }
            targetX = this.wanderTarget.x;
            targetY = this.wanderTarget.y;
        }

        // Calculate angle towards target
        const targetDx = targetX - this.x;
        const targetDy = targetY - this.y;
        let desiredAngle = Math.atan2(targetDy, targetDx);

        // TODO: Add Obstacle Avoidance (check for other snakes nearby and steer away)
        // This is more complex, involves checking points ahead of the snake

        // Smoothly turn towards desired angle
        let angleDiff = desiredAngle - this.currentAngle;
        while (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;
        while (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;

        // Limit turning speed
        const turn = Math.max(-this.aiTurnSpeed, Math.min(this.aiTurnSpeed, angleDiff));
        let nextAngle = this.currentAngle + turn;

        // Update the AI snake's movement
        this.update(nextAngle, baseSpeed * 0.9); // AI slightly slower?
    }


    grow(amount = 1) {
        this.length += amount;
        score += amount; // Increase score when player grows
    }

    draw(ctx) {
        // Draw segments with gradient for Slither.io look
        for (let i = this.segments.length - 1; i >= 0; i--) {
            const seg = this.segments[i];
            const nextSeg = this.segments[i - 1] || seg; // Use current if it's the head

            // Simple circle for now, gradients are more complex
            ctx.beginPath();
            ctx.arc(seg.x, seg.y, this.radius, 0, Math.PI * 2);
            ctx.fillStyle = this.color; // Apply pattern/gradient later
            ctx.fill();
        }

        // Draw Eyes (on the head segment)
        const head = this.segments[0];
        const eyeSize = this.radius * 0.4;
        const pupilSize = eyeSize * 0.5;
        const eyeOffset = this.radius * 0.5; // Distance from center

        // Calculate eye positions based on angle
        const eyeAngle1 = this.currentAngle + Math.PI / 2;
        const eyeAngle2 = this.currentAngle - Math.PI / 2;

        const eyeX1 = head.x + Math.cos(eyeAngle1) * eyeOffset;
        const eyeY1 = head.y + Math.sin(eyeAngle1) * eyeOffset;
        const eyeX2 = head.x + Math.cos(eyeAngle2) * eyeOffset;
        const eyeY2 = head.y + Math.sin(eyeAngle2) * eyeOffset;

        // White part
        ctx.fillStyle = 'white';
        ctx.beginPath();
        ctx.arc(eyeX1, eyeY1, eyeSize, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(eyeX2, eyeY2, eyeSize, 0, Math.PI * 2);
        ctx.fill();

        // Pupil part (looking towards movement direction)
        const pupilOffsetX = Math.cos(this.currentAngle) * eyeSize * 0.3;
        const pupilOffsetY = Math.sin(this.currentAngle) * eyeSize * 0.3;
        ctx.fillStyle = 'black';
        ctx.beginPath();
        ctx.arc(eyeX1 + pupilOffsetX, eyeY1 + pupilOffsetY, pupilSize, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(eyeX2 + pupilOffsetX, eyeY2 + pupilOffsetY, pupilSize, 0, Math.PI * 2);
        ctx.fill();
    }
}

// --- Controls ---
function setupControls() {
    // Mouse/Touch for direction
    const getTargetAngle = (x, y) => {
        // Calculate angle from center of screen (player position) to cursor/touch point
        const dx = x - canvasWidth / 2;
        const dy = y - canvasHeight / 2;
        return Math.atan2(dy, dx);
    };

    canvas.addEventListener('mousemove', (e) => {
        targetAngle = getTargetAngle(e.clientX, e.clientY);
    });

    canvas.addEventListener('touchmove', (e) => {
        e.preventDefault(); // Prevent scrolling
        const touch = e.touches[0];
        targetAngle = getTargetAngle(touch.clientX, touch.clientY);
    }, { passive: false });

     canvas.addEventListener('touchstart', (e) => {
        e.preventDefault();
        const touch = e.touches[0];
        targetAngle = getTargetAngle(touch.clientX, touch.clientY);
        // Maybe add boost on touch start?
     }, { passive: false });

    // Keyboard (Optional fallback for desktop)
    // You might map keys to specific angles or have WASD control angle change
}

// --- Collision Detection ---
function checkCollisions() {
    const head = playerSnake.segments[0];

    // 1. Food Collision
    for (let i = food.length - 1; i >= 0; i--) {
        const f = food[i];
        const dx = head.x - f.x;
        const dy = head.y - f.y;
        const distSq = dx * dx + dy * dy;
        const radiiSumSq = (playerSnake.radius + f.radius) ** 2;

        if (distSq < radiiSumSq) {
            playerSnake.grow();
            // Respawn food elsewhere
            food[i] = new Food(Math.random() * worldSize, Math.random() * worldSize);
        }
    }

    // 2. Snake vs Snake Collision (Player vs AI, AI vs AI)
    const allSnakes = [playerSnake, ...aiSnakes];
    for (let i = 0; i < allSnakes.length; i++) {
        const snakeA = allSnakes[i];
        const headA = snakeA.segments[0];

        for (let j = 0; j < allSnakes.length; j++) {
            const snakeB = allSnakes[j];
             // Check if snakeA's head hits any segment of snakeB (excluding its own head)
            for(let k = 1; k < snakeB.segments.length; k++) { // Start from k=1 to avoid head-on-head detection unless desired
                 const segB = snakeB.segments[k];
                 const dx = headA.x - segB.x;
                 const dy = headA.y - segB.y;
                 const distSq = dx*dx + dy*dy;
                 const radiiSumSq = (snakeA.radius + snakeB.radius * 0.8)**2; // Use slightly smaller radius for body segments

                 if (distSq < radiiSumSq) {
                     // Collision detected! Snake A hit Snake B
                     console.log("Collision!");
                     handleCollision(snakeA, snakeB);
                     return; // Handle one collision per frame for simplicity
                 }
            }
        }
    }

    // 3. Boundary Collision (If not wrapping around)
    // if (head.x < 0 || head.x > worldSize || head.y < 0 || head.y > worldSize) {
    //    handleCollision(playerSnake, null); // Hit boundary
    // }
}

function handleCollision(colliderSnake, collidedSnake) {
    // If player collided
    if (colliderSnake === playerSnake) {
        console.log("Game Over!");
        gameState = 'gameOver';
        // Turn player snake into food
        spawnFoodFromSnake(playerSnake);
        // Maybe reset playerSnake or show menu
    } else {
         // An AI snake collided
         console.log("AI died");
         spawnFoodFromSnake(colliderSnake);
         // Remove the dead AI snake
         const index = aiSnakes.indexOf(colliderSnake);
         if (index > -1) {
             aiSnakes.splice(index, 1);
             // Add a new AI snake to replace it?
             const aiX = Math.random() * worldSize;
             const aiY = Math.random() * worldSize;
             const aiColor = `hsl(${Math.random() * 360}, 70%, 50%)`;
             aiSnakes.push(new Snake(aiX, aiY, 8, aiColor, true));
         }
    }
}

function spawnFoodFromSnake(snake) {
    // Drop food items along the snake's body path
    snake.segments.forEach((seg, index) => {
        if (index % 5 === 0) { // Drop food every 5 segments or so
             food.push(new Food(seg.x + (Math.random()-0.5)*5, seg.y + (Math.random()-0.5)*5)); // Add slight randomness
        }
    });
}


// --- Start Everything ---
init();</script>
</body>
</html>